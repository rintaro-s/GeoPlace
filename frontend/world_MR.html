<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GeoPlace - 3D World (VR/MR)</title>
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <!-- Teleport controls for VR controllers -->
    <script src="https://unpkg.com/aframe-teleport-controls@^5.0.0/dist/aframe-teleport-controls.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        
        #ui {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 8px;
            color: white;
            min-width: 250px;
        }
        
        #controls {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 8px;
            color: white;
        }
        
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            margin: 2px;
            font-size: 12px;
        }
        
        button:hover { background: #45a049; }
        
        .status { color: #4CAF50; font-weight: bold; }
        .error { color: #f44336; }
        .info { color: #2196F3; }
        
        #object-list {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
            font-size: 12px;
        }
        
        .object-item {
            padding: 5px;
            border-bottom: 1px solid #444;
            cursor: pointer;
        }
        
        .object-item:hover {
            background: rgba(76, 175, 80, 0.2);
        }
    </style>
</head>
<body>
    <div id="ui">
        <h3>üåç 3D World (VR/MR)</h3>
        <div id="status">Loading...</div>
        <div>Objects: <span id="object-count">0</span></div>
    <div>Position: <span id="position">0, 0, 0</span></div>
    <div>Teleport target: <span id="teleport-target">--, --, --</span></div>
        <div id="object-list"></div>
    </div>
    
    <div id="controls">
        <h4>Controls</h4>
        <div style="margin-bottom:8px">
            <input id="search-input" type="text" placeholder="‰ºº„Å¶„ÇãÁµµ„ÇíÊ§úÁ¥¢„Åó„Å¶„Åø„Çà„ÅÜÔºà‰æã: Ëµ§„ÅÑÂÆ∂Ôºâ" style="width:160px;padding:6px;border-radius:4px;border:1px solid #666"> 
            <button onclick="doSearch()">üîé Search</button>
            <button onclick="window.open('/tools/faq.html','_blank')" title="FAQ„ÇíÈñã„Åè">‚ùì FAQ</button>
            <div id="search-results" style="max-height:200px; overflow:auto; margin-top:6px; font-size:12px; color:#fff"></div>
        </div>
        <button onclick="refreshObjects()">üîÑ Refresh</button>
        <button onclick="resetCamera()">üì∑ Reset View</button>
        <button onclick="window.open('/paint', '_blank')">üé® Paint Tool</button>
        <button onclick="window.open('/admin', '_blank')">‚öôÔ∏è Admin</button>
        <div style="margin-top:8px">
            <label style="font-size:12px">Tile visual scale: <span id="tile-scale-label">0.25</span></label><br>
            <input id="tile-scale" type="range" min="0.05" max="1.0" step="0.01" value="0.25" oninput="onTileScaleChange(this.value)">
        </div>
        <div style="margin-top:8px">
            <label style="font-size:12px">Movement speed: <span id="move-speed-label">1.0</span></label><br>
            <input id="move-speed" type="range" min="0.2" max="5.0" step="0.1" value="1.0" oninput="onMoveSpeedChange(this.value)">
        </div>
    </div>

    <!-- MR-capable scene: VR UI enabled, WebXR optional features, and teleport/laser controllers -->
    <a-scene 
        background="color: #87CEEB"
        fog="type: linear; color: #87CEEB; near: 50; far: 200"
        vr-mode-ui="enabled: true"
        renderer="colorManagement: true; physicallyCorrectLights: true"
        webxr="optionalFeatures: local-floor">
        
        <!-- Lighting -->
        <a-light type="ambient" color="#404040"></a-light>
        <a-light type="directional" position="10 20 10" color="#ffffff" intensity="0.8"></a-light>
        
        <!-- Ground: teleportable for VR controllers -->
        <a-plane id="ground-plane"
            class="teleportable"
            position="0 -0.5 0"
            rotation="-90 0 0"
            width="100"
            height="100"
            material="color: #ffffff; side: double"
            shadow="receive: true">
        </a-plane>
        
        <!-- Grid -->
        <a-entity id="grid-system">
            <!-- Grid lines will be added dynamically -->
        </a-entity>
        
        <!-- Camera with movement controls and gaze/mouse cursor for desktop fallback -->
        <a-entity id="camera-rig" position="0 1.6 5">
            <a-camera 
                id="camera"
                look-controls="pointerLockEnabled: true"
                wasd-controls="fly: true; acceleration: 80"
                position="0 0 0">
                <!-- Add a cursor for desktop and gaze interaction -->
                <a-entity cursor="fuse: false; rayOrigin: mouse" 
                          raycaster="objects: .clickable" 
                          position="0 0 -1"
                          geometry="primitive: ring; radiusInner: 0.01; radiusOuter: 0.02"
                          material="color: #fff; shader: flat">
                </a-entity>
            </a-camera>
        </a-entity>

        <!-- Controller entities: laser + teleport support -->
        <a-entity id="left-hand" hand-controls="left" laser-controls="hand: left" 
                  teleport-controls="cameraRig: #camera-rig; collisionEntities: .teleportable; button: grip; type: parabolic; curveShootingSpeed: 10">
        </a-entity>

        <a-entity id="right-hand" hand-controls="right" laser-controls="hand: right" 
                  teleport-controls="cameraRig: #camera-rig; collisionEntities: .teleportable; button: trigger; type: direct">
        </a-entity>
        
        <!-- Objects container -->
        <a-entity id="objects-container"></a-entity>
        <!-- Demo 3D model to inspect -->
        <a-entity id="demo-model" position="5 0 5" rotation="0 45 0" scale="0.6 0.6 0.6"
                  gltf-model="/assets/glb/ce75997479da8e0c9f1239e8e04ff1e4758a1af985d2540f78585ed848132cde_light.glb"
                  shadow="cast: true; receive: true">
            <a-animation attribute="rotation" to="0 405 0" dur="20000" easing="linear" repeat="indefinite"></a-animation>
        </a-entity>
    </a-scene>

    <script>
    let objects = [];
    let camera, cameraRig, objectsContainer;
    // When the page is opened from file://, use local server as base
    const baseUrl = (location.protocol === 'file:') ? 'http://127.0.0.1:8001' : '';
        
        document.addEventListener('DOMContentLoaded', init);
        
        function init() {
            // Get A-Frame elements
            camera = document.querySelector('#camera');
            cameraRig = document.querySelector('#camera-rig');
            objectsContainer = document.querySelector('#objects-container');
            
            // Setup grid
            createGrid();
            
                // Load initial objects
                    loadObjects();

                    // Apply initial ground sizing and position according to current tile-scale value
                    try {
                        onTileScaleChange(document.getElementById('tile-scale').value);
                    } catch (e) {
                        console.warn('Failed to initialize ground scale:', e);
                    }
                // set ground material to use server-hosted canvas.png (works with file:// when baseUrl is set)
                try {
                    const ground = document.getElementById('ground-plane');
                    if (ground) {
                        ground.setAttribute('material', `src: ${baseUrl + '/data/canvas.png'}; repeat: 1 1; side: double`);
                    }
                    // set demo model src to use baseUrl if needed
                    const demo = document.getElementById('demo-model');
                    if (demo) {
                        demo.setAttribute('gltf-model', baseUrl + '/assets/glb/ce75997479da8e0c9f1239e8e04ff1e4758a1af985d2540f78585ed848132cde_light.glb');
                    }
                } catch (e) {
                    console.warn('Failed to set ground/demo assets with baseUrl:', e);
                }
            
            // Setup position tracking
            setInterval(updatePosition, 1000);
            
            log('3D World (VR/MR) initialized', 'status');
        }

        // --- Helper utilities for robust texture handling ---
        // Check if an image URL exists and is loadable (handles CORS by using Image)
        function imageExists(url) {
            return new Promise((resolve) => {
                try {
                    const img = new Image();
                    img.onload = () => resolve(true);
                    img.onerror = () => resolve(false);
                    img.src = url;
                } catch (e) { resolve(false); }
            });
        }

        // Ensure meshes have UVs; if missing, generate simple planar projection UVs based on bbox
        function ensureUVs(object3d) {
            try {
                object3d.traverse((node) => {
                    if (node.isMesh && node.geometry && node.geometry.isBufferGeometry) {
                        const geom = node.geometry;
                        if (!geom.attributes.uv || geom.attributes.uv.count === 0) {
                            // compute bounding box
                            if (!geom.boundingBox) geom.computeBoundingBox();
                            const bbox = geom.boundingBox;
                            const size = new THREE.Vector3();
                            bbox.getSize(size);
                            const pos = geom.attributes.position;
                            const count = pos.count || (pos.array ? pos.array.length / 3 : 0);
                            const uvs = new Float32Array(count * 2);
                            for (let i = 0; i < count; i++) {
                                const x = pos.getX ? pos.getX(i) : pos.array[i*3];
                                const y = pos.getY ? pos.getY(i) : pos.array[i*3+1];
                                const z = pos.getZ ? pos.getZ(i) : pos.array[i*3+2];
                                // project to XZ plane (upright models) fallback to XY
                                const u = size.x > 0 ? (x - bbox.min.x) / size.x : 0;
                                const v = size.z > 0 ? (z - bbox.min.z) / size.z : (size.y > 0 ? (y - bbox.min.y) / size.y : 0);
                                uvs[i*2] = u;
                                uvs[i*2+1] = v;
                            }
                            geom.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
                            geom.attributes.uv.needsUpdate = true;
                        }
                    }
                });
            } catch (e) {
                console.warn('ensureUVs failed', e);
            }
        }

        // Try to apply a texture from a list of candidate URLs to the object if no material map present
        async function tryApplyTextureToObject(threeObj, candidates) {
            try {
                // detect if already has a map
                let hasMap = false;
                threeObj.traverse((node) => {
                    if (node.isMesh && node.material) {
                        const mats = Array.isArray(node.material) ? node.material : [node.material];
                        for (const m of mats) if (m && m.map) { hasMap = true; break; }
                    }
                });
                if (hasMap) return true;

                // find first existing candidate
                let found = null;
                for (const u of candidates) {
                    // eslint-disable-next-line no-await-in-loop
                    if (await imageExists(u)) { found = u; break; }
                }
                if (!found) return false;

                // ensure UVs exist before applying
                ensureUVs(threeObj);

                const loader = new THREE.TextureLoader();
                return new Promise((resolve) => {
                    loader.load(found, (tex) => {
                        try {
                            tex.flipY = false;
                            threeObj.traverse((node) => {
                                if (node.isMesh) {
                                    const mats = Array.isArray(node.material) ? node.material : [node.material];
                                    for (const m of mats) {
                                        try { if (m) { m.map = tex; m.needsUpdate = true; } } catch (e) {}
                                    }
                                }
                            });
                            resolve(true);
                        } catch (e) { resolve(false); }
                    }, undefined, () => { resolve(false); });
                });
            } catch (e) {
                console.warn('tryApplyTextureToObject failed', e);
                return false;
            }
        }

    // Canvas mapping: the original canvas.png is very large (22400 x 21966), tile size 32x32 px
    // Backend places objects with: x = tx * tile_size / 10.0, z = ty * tile_size / 10.0
    // We'll use the same scale to keep 2D paint coordinates and 3D world coordinates consistent.
    const CANVAS_PX_W = 22400;
    const CANVAS_PX_H = 21966;
    const TILE_PX = 32;
    // world units per tile used by backend
    const BACKEND_TILE_WORLD = TILE_PX / 10.0; // matches backend's tx * tile_size / 10.0
    // baseTileWorldSize is a visual multiplier controlled by UI; default 1.0 matches backend scale
    let baseTileWorldSize = 1.0;

        function onTileScaleChange(val){
            const s = parseFloat(val);
            document.getElementById('tile-scale-label').textContent = s.toFixed(2);
            // adjust ground plane size / texture repeat to reflect scale
            const worldW = (CANVAS_PX_W / TILE_PX) * BACKEND_TILE_WORLD * baseTileWorldSize * s;
            const worldH = (CANVAS_PX_H / TILE_PX) * BACKEND_TILE_WORLD * baseTileWorldSize * s;
            const ground = document.getElementById('ground-plane');
            if (ground) {
                ground.setAttribute('width', worldW);
                ground.setAttribute('height', worldH);
                // set texture once across the plane
                ground.setAttribute('material', `src: /data/canvas.png; repeat: 1 1; side: double`);
                // Because A-Frame plane is centered at its position, shift it so that
                // canvas (0,0) which is top-left in 2D maps to the plane's top-left.
                // We'll position the plane's center at (worldW/2, 0, worldH/2) and then
                // set camera/start position accordingly.
                // Note: backend's object positions assume origin at top-left mapping to positive x/z.
                ground.setAttribute('position', `${worldW/2} -0.5 ${worldH/2}`);
            }
            // Re-render objects so they move/scale with the ground
            try {
                renderObjects();
            } catch (e) {
                console.warn('Failed to re-render objects after scale change', e);
            }
        }

        function onMoveSpeedChange(val){
            const s = parseFloat(val);
            document.getElementById('move-speed-label').textContent = s.toFixed(1);
            // update wasd-controls speed - A-Frame's default uses acceleration/velocity; set fly speed multiplier
            const cam = document.querySelector('#camera');
            if (cam) {
                // wasd-controls doesn't expose speed directly in older versions; we set acceleration to scale
                cam.setAttribute('wasd-controls', `fly: true; acceleration: ${80 * s}`);
            }
        }

        // initialize UI values
        window.addEventListener('load', ()=>{
            onTileScaleChange(document.getElementById('tile-scale').value);
            onMoveSpeedChange(document.getElementById('move-speed').value);
        });
        
        function createGrid() {
            const gridContainer = document.querySelector('#grid-system');
            const gridSize = 100;
            const gridSpacing = 10;
            
            // Create grid lines
            for (let i = -gridSize; i <= gridSize; i += gridSpacing) {
                // X-axis lines
                const lineX = document.createElement('a-box');
                lineX.setAttribute('position', `${i} 0 0`);
                lineX.setAttribute('width', '0.1');
                lineX.setAttribute('height', '0.1');
                lineX.setAttribute('depth', gridSize * 2);
                lineX.setAttribute('color', '#444444');
                gridContainer.appendChild(lineX);
                
                // Z-axis lines
                const lineZ = document.createElement('a-box');
                lineZ.setAttribute('position', `0 0 ${i}`);
                lineZ.setAttribute('width', gridSize * 2);
                lineZ.setAttribute('height', '0.1');
                lineZ.setAttribute('depth', '0.1');
                lineZ.setAttribute('color', '#444444');
                gridContainer.appendChild(lineZ);
            }
        }
        
        async function loadObjects() {
            try {
                log('Loading 3D objects...', 'info');
                
                    // fetch objects from backend FastAPI endpoint
                    const response = await fetch(baseUrl + '/api/objects.json');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                objects = await response.json();
                // Objects from backend already use world-unit placement (see backend.job_thread)
                renderObjects();
                
                log(`‚úÖ Loaded ${objects.length} objects`, 'status');
                
            } catch (error) {
                log(`‚ùå Failed to load objects: ${error.message}`, 'error');
            }
        }
        
        async function renderObjects() {
            // Clear existing objects
            objectsContainer.innerHTML = '';

            // Update UI
            document.getElementById('object-count').textContent = objects.length;

            // Render object list
            const objectList = document.getElementById('object-list');
            objectList.innerHTML = '';

            // compute display scale multiplier (backend world units -> displayed units)
            const scaleMultiplier = baseTileWorldSize * parseFloat(document.getElementById('tile-scale').value || '1.0');

            for (let index = 0; index < objects.length; index++) {
                const obj = objects[index];
                const entity = document.createElement('a-entity');
                entity.setAttribute('id', `object-${obj.id || index}`);
                // make interactable by raycasters / cursor
                try { entity.classList.add('clickable'); } catch(e){}

                // Apply display scaling so object positions align with ground plane scaling
                const px = (obj.x || 0) * scaleMultiplier;
                const py = (obj.y || 0);
                const pz = (obj.z || 0) * scaleMultiplier;
                entity.setAttribute('position', `${px} ${py + 1} ${pz}`);
                // apply rotation from objects.json if present
                try {
                    if (obj.rotation && obj.rotation.length === 3) {
                        entity.setAttribute('rotation', `${obj.rotation[0]} ${obj.rotation[1]} ${obj.rotation[2]}`);
                    }
                } catch (e) {
                    console.warn('Failed to set rotation for', obj.id, e);
                }

                const url = obj.glb_url || '';
                if (url && url !== '/assets/glb/GLB_PLACEHOLDER') {
                    if (url.toLowerCase().endsWith('.obj')) {
                        // prefetch and check OBJ content to detect corrupt/dummy files
                        try {
                            const resp = await fetch(baseUrl + url);
                            if (!resp.ok) throw new Error('HTTP ' + resp.status);
                            const text = await resp.text();
                            if (!/^[ \t]*v\s+/m.test(text)) {
                                console.warn('OBJ appears invalid or contains no vertex data:', url);
                                createTexturedPlaneFallback(entity, baseUrl + url.replace(/\.obj$/i, '_fallback.png'));
                            } else {
                                const mtlUrl = url.replace(/\.obj$/i, '.mtl');
                                // set basic OBJ load (mtl may be missing)
                                entity.setAttribute('obj-model', `obj: ${baseUrl + url}`);
                                entity.setAttribute('scale', '0.6 0.6 0.6');

                                // After model loads, try to apply PNG texture candidates and ensure UVs
                                entity.addEventListener('model-loaded', async function (evt) {
                                    try {
                                        const threeObj = this.getObject3D('mesh') || this.getObject3D('model');
                                        if (!threeObj) return;

                                        const pngCandidates = [baseUrl + url.replace(/\.obj$/i, '.png'), baseUrl + url.replace(/\.obj$/i, '_fallback.png')];
                                        // try to apply texture if needed (this will also ensure UVs)
                                        await tryApplyTextureToObject(threeObj, pngCandidates);
                                    } catch (e) {
                                        console.warn('Failed to apply PNG texture to OBJ', url, e);
                                    }
                                });

                                entity.addEventListener('model-error', function (evt) {
                                    console.warn('OBJ model-error for', url, evt);
                                    createTexturedPlaneFallback(this, baseUrl + url.replace(/\.obj$/i, '_fallback.png'));
                                });
                            }
                        } catch (e) {
                            console.warn('Failed to fetch/check OBJ:', url, e);
                            createTexturedPlaneFallback(entity, baseUrl + url.replace(/\.obj$/i, '_fallback.png'));
                        }
                    } else {
                        // Robust loader: fetch content and inspect bytes/text to determine
                        // whether this is a real GLB, a mislabeled OBJ, or a placeholder.
                        (async () => {
                            try {
                                const resp = await fetch(baseUrl + url);
                                if (!resp.ok) throw new Error('HTTP ' + resp.status);
                                // Attempt to read as arrayBuffer so we can inspect binary headers
                                const buf = await resp.arrayBuffer();
                                const bytes = new Uint8Array(buf);
                                // preview first 256 bytes as text for quick heuristics
                                let preview = '';
                                try { preview = new TextDecoder('utf-8', {fatal:false}).decode(bytes.slice(0,256)); } catch(e) { preview = ''; }

                                // Detect explicit placeholder markers (defensive)
                                if (preview.includes('GLB_PLACEHOLDER') || preview.includes('GLB_FALLBACK') || preview.includes('DUMMY_GLB')) {
                                    throw new Error('placeholder');
                                }

                                // Detect if the payload is actually OBJ text (some servers may misname)
                                if (/^[\s]*v\s+/m.test(preview) || preview.includes('mtllib') || preview.includes('usemtl')) {
                                    // treat as OBJ text
                                    const text = new TextDecoder().decode(bytes);
                                    // If MTL reference exists, try to fetch it; otherwise generate a minimal mtl
                                    let mtlBlobUrl = null;
                                    const mtlMatch = text.match(/^mtllib\s+(.+)$/m);
                                    if (mtlMatch) {
                                        const mtlName = mtlMatch[1].trim();
                                        try {
                                            const mtlResp = await fetch(new URL(mtlName, baseUrl + url).href);
                                            if (mtlResp.ok) {
                                                const mtlText = await mtlResp.text();
                                                const mtlBlob = new Blob([mtlText], {type:'text/plain'});
                                                mtlBlobUrl = URL.createObjectURL(mtlBlob);
                                            }
                                        } catch(e){}
                                    }
                                    if (!mtlBlobUrl) {
                                        // generate a minimal MTL
                                        const gen = 'newmtl fallback\nKd 0.8 0.8 0.8\n';
                                        const mtlBlob = new Blob([gen], {type:'text/plain'});
                                        mtlBlobUrl = URL.createObjectURL(mtlBlob);
                                    }
                                    const objBlob = new Blob([text], {type:'text/plain'});
                                    const objUrl = URL.createObjectURL(objBlob);
                                    entity.setAttribute('obj-model', `obj: ${objUrl}; mtl: ${mtlBlobUrl}`);
                                    return;
                                }

                                // Detect GLB binary header 'glTF'
                                const magic = String.fromCharCode(bytes[0] || 0, bytes[1] || 0, bytes[2] || 0, bytes[3] || 0);
                                    if (magic === 'glTF') {
                                    const blob = new Blob([buf], {type: 'model/gltf-binary'});
                                    const blobUrl = URL.createObjectURL(blob);
                                    entity.setAttribute('gltf-model', blobUrl);
                                    entity.setAttribute('scale', '0.6 0.6 0.6');
                                    // attach model-loaded to adjust bbox scaling
                                        entity.addEventListener('model-loaded', async function () {
                                            try {
                                                const model = this.getObject3D('mesh') || this.getObject3D('model');
                                                if (model) {
                                                    // ensure UVs exist for glb before applying any fallback texture
                                                    ensureUVs(model);
                                                    const box = new THREE.Box3().setFromObject(model);
                                                    const size = new THREE.Vector3();
                                                    box.getSize(size);
                                                    const maxDim = Math.max(size.x, size.y, size.z);
                                                    if (maxDim > 0) {
                                                        const target = 2.0 * scaleMultiplier;
                                                        const factor = target / maxDim;
                                                        this.object3D.scale.set(factor, factor, factor);
                                                    }
                                                    // try candidate textures: same basename.png and _fallback.png
                                                    const pngCandidates = [baseUrl + url.replace(/\.glb$/i, '.png'), baseUrl + url.replace(/\.glb$/i, '_fallback.png')];
                                                    await tryApplyTextureToObject(model, pngCandidates);
                                                }
                                            } catch (e) {
                                                console.warn('Error computing bbox for glb or applying texture', baseUrl + url, e);
                                            }
                                        });
                                    // on error, attempt OBJ fallbacks below
                                    entity.addEventListener('model-error', function (evt) {
                                        console.warn('gltf-model failed for blob', baseUrl + url, evt);
                                        try { this.removeAttribute('gltf-model'); } catch(e){}
                                    });
                                    return;
                                }

                                // Unknown binary/text payload - fall back to trying candidate OBJ files
                                throw new Error('unknown-format');

                            } catch (e) {
                                // Try candidate OBJ fallbacks (same logic as before)
                                try {
                                    const baseName = url.replace(/\.glb$/i, '');
                                    const candidates = [
                                        baseName + '.obj',
                                        baseName + '_light.obj',
                                        baseName + '_refined.obj',
                                        baseName + '_fallback.obj'
                                    ];
                                    const alt = baseName.replace(/_refined$|_light$/i, '');
                                    if (alt !== baseName) {
                                        candidates.push(alt + '.obj', alt + '_light.obj', alt + '_refined.obj');
                                    }
                                    const seen = new Set();
                                    const uniq = candidates.filter(c => { if (seen.has(c)) return false; seen.add(c); return true; });
                                    let found = false;
                                    for (const cand of uniq) {
                                        try {
                                            const head = await fetch(baseUrl + cand, { method: 'HEAD' });
                                            if (!head.ok) continue;
                                            const resp2 = await fetch(baseUrl + cand);
                                            if (!resp2.ok) continue;
                                            const text = await resp2.text();
                                            if (!/^[\s]*v\s+/m.test(text)) continue;
                                            // create mtl blob if needed
                                            let mtlBlobUrl = null;
                                            const mtlMatch = text.match(/^mtllib\s+(.+)$/m);
                                            if (mtlMatch) {
                                                const mtlName = mtlMatch[1].trim();
                                                try {
                                                    const mtlResp = await fetch(new URL(mtlName, baseUrl + cand).href);
                                                    if (mtlResp.ok) {
                                                        const mtlText = await mtlResp.text();
                                                        const mtlBlob = new Blob([mtlText], {type:'text/plain'});
                                                        mtlBlobUrl = URL.createObjectURL(mtlBlob);
                                                    }
                                                } catch(e){}
                                            }
                                            if (!mtlBlobUrl) {
                                                const gen = 'newmtl fallback\nKd 0.8 0.8 0.8\n';
                                                const mtlBlob = new Blob([gen], {type:'text/plain'});
                                                mtlBlobUrl = URL.createObjectURL(mtlBlob);
                                            }
                                            const objBlob = new Blob([text], {type:'text/plain'});
                                            const objUrl = URL.createObjectURL(objBlob);
                                            entity.setAttribute('obj-model', `obj: ${objUrl}; mtl: ${mtlBlobUrl}`);
                                            found = true;
                                            break;
                                        } catch (inner) {
                                            continue;
                                        }
                                    }
                                    if (!found) {
                                        try { this.removeObject3D && this.removeObject3D('mesh'); } catch(e){}
                                        try { this.removeObject3D && this.removeObject3D('model'); } catch(e){}
                                        while (entity.firstChild) entity.removeChild(entity.firstChild);
                                        createTexturedPlaneFallback(entity, baseUrl + url.replace(/\.glb$/i, '_fallback.png'));
                                    }
                                } catch (outer) {
                                    console.warn('Failed robust model load for', baseUrl + url, outer);
                                    try { while (entity.firstChild) entity.removeChild(entity.firstChild); } catch(e){}
                                    createTexturedPlaneFallback(entity, baseUrl + url.replace(/\.glb$/i, '_fallback.png'));
                                }
                            }
                        })();
                    }
                } else {
                    // Fallback: colored box
                    entity.setAttribute('geometry', 'primitive: box; width: 1; height: 1; depth: 1');
                    const colors = ['#ff4444', '#44ff44', '#4444ff', '#ffff44', '#ff44ff'];
                    entity.setAttribute('material', `color: ${colors[index % colors.length]}`);
                }

                // Add shadow
                entity.setAttribute('shadow', 'cast: true; receive: true');

                // Add click interaction
                entity.setAttribute('cursor-listener', '');
                entity.addEventListener('click', () => {
                    focusOnObject(obj);
                });

                objectsContainer.appendChild(entity);

                // Create a text label slightly above the entity so viewers can identify IDs
                const label = document.createElement('a-entity');
                label.setAttribute('id', `label-${obj.id || index}`);
                // label position matches entity position but slightly elevated
                label.setAttribute('position', `${px} ${py + 2} ${pz}`);
                label.setAttribute('text', `value: ${obj.id || index}; align: center; color: #fff; width: 4`);
                label.setAttribute('visible', true);
                // prevent labels from interfering with raycaster interactions
                label.classList.add('object-label');
                objectsContainer.appendChild(label);

                // Add to UI list (show scaled coords so list matches view)
                const listItem = document.createElement('div');
                listItem.className = 'object-item';
                listItem.textContent = `${obj.id || index}: (${Math.round(px)}, ${Math.round(py)}, ${Math.round(pz)})`;
                listItem.onclick = () => focusOnObject(obj);
                objectList.appendChild(listItem);
            }
        }
        
        function focusOnObject(obj) {
            const scaleMultiplier = baseTileWorldSize * parseFloat(document.getElementById('tile-scale').value || '1.0');
            const tx = (obj.x || 0) * scaleMultiplier;
            const ty = (obj.y || 0) + 5;
            const tz = (obj.z || 0) * scaleMultiplier;
            const targetPos = `${tx} ${ty} ${tz}`;
            const dur = 1000;
            // show intended teleport target in UI
            document.getElementById('teleport-target').textContent = `${Math.round(tx)}, ${Math.round(ty)}, ${Math.round(tz)}`;
            cameraRig.setAttribute('animation', `property: position; to: ${targetPos}; dur: ${dur}`);
            // force final exact position after animation completes to avoid tiny mismatches
            setTimeout(() => {
                try {
                    cameraRig.setAttribute('position', targetPos);
                    // also update camera HUD immediately
                    updatePosition();
                } catch (e) {
                    console.warn('Failed to set final camera position precisely', e);
                }
            }, dur + 50);
            log(`Focusing on object at (${obj.x}, ${obj.y}, ${obj.z})`, 'info');
        }

        // --- Search integration ---
        async function doSearch() {
            const q = document.getElementById('search-input').value.trim();
            if (!q) return;
            const resultsDiv = document.getElementById('search-results');
            resultsDiv.innerHTML = 'Ê§úÁ¥¢‰∏≠‚Ä¶';
            try {
                const resp = await fetch('/api/search?q=' + encodeURIComponent(q) + '&top_k=10&target=world_new');
                if (!resp.ok) throw new Error('HTTP ' + resp.status);
                const j = await resp.json();
                const res = j.results || [];
                if (!res.length) {
                    resultsDiv.innerHTML = '<div>Ë¶ã„Å§„Åã„Çâ„Å™„Åã„Å£„Åü„Çà„Äú üòä</div>';
                    return;
                }
                resultsDiv.innerHTML = '';
                for (const r of res) {
                    // skip zero-score results (server indicates non-match)
                    if ((r.score || 0) <= 0.0) continue;
                    const el = document.createElement('div');
                    el.style.padding = '6px';
                    el.style.borderBottom = '1px solid #333';
                    el.style.cursor = 'pointer';
                    const txt = (r.text || '').slice(0,120).replace(/\n/g,' ');
                    const commentHtml = r.comment ? `<div style="color:#ffddc1;font-size:12px;margin-top:4px">${r.comment}</div>` : '';
                    el.innerHTML = `<div style="font-size:13px">${(r.score||0).toFixed(2)} ‚Äî ${txt}</div>` + commentHtml;
                    el.onclick = () => {
                        // try to focus on coords if available
                        if (r.coords && Array.isArray(r.coords) && r.coords.length>=2) {
                            const [x,y] = r.coords;
                            // Create a dummy object to reuse focus logic (y axis mapping may vary)
                            focusOnObject({x: x, y: 0, z: y});
                        } else if (r.id) {
                            // try to find object by id in objects list
                            const found = objects.find(o => o.id == r.id);
                            if (found) focusOnObject(found);
                        }
                    };
                    resultsDiv.appendChild(el);
                }
            } catch (e) {
                resultsDiv.innerHTML = '<div class="error">Ê§úÁ¥¢„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ' + e.message + '</div>';
            }
        }
        
        function updatePosition() {
            if (cameraRig) {
                const pos = cameraRig.getAttribute('position');
                const posText = `${Math.round(pos.x)}, ${Math.round(pos.y)}, ${Math.round(pos.z)}`;
                document.getElementById('position').textContent = posText;
                // if teleport-target matches current position (within 1 unit), clear it
                const t = document.getElementById('teleport-target').textContent.split(',').map(s=>parseInt(s));
                if (t.length===3) {
                    const dx = Math.abs(Math.round(pos.x) - t[0]);
                    const dy = Math.abs(Math.round(pos.y) - t[1]);
                    const dz = Math.abs(Math.round(pos.z) - t[2]);
                    if (dx<=1 && dy<=1 && dz<=1) {
                        document.getElementById('teleport-target').textContent = '--, --, --';
                    }
                }
            }
        }
        
        function refreshObjects() {
            log('Refreshing objects...', 'info');
            loadObjects();
        }

        function createTexturedPlaneFallback(entity, pngUrl) {
            try {
                // remove model-related attributes
                entity.removeAttribute('obj-model');
                entity.removeAttribute('gltf-model');
                // create a child plane that uses the PNG as texture
                const plane = document.createElement('a-plane');
                // position plane slightly above ground
                plane.setAttribute('position', '0 0 0');
                plane.setAttribute('rotation', '-90 0 0');
                plane.setAttribute('width', '1');
                plane.setAttribute('height', '1');
                plane.setAttribute('material', `src: ${pngUrl}; side: double`);
                plane.setAttribute('scale', '1 1 1');
                entity.appendChild(plane);
            } catch (e) {
                console.warn('Failed to create textured plane fallback', e);
            }
        }
        
        function resetCamera() {
            cameraRig.setAttribute('position', '0 5 10');
            camera.setAttribute('rotation', '0 0 0');
            log('Camera reset', 'info');
        }
        
        function log(message, type = 'info') {
            const status = document.getElementById('status');
            const timestamp = new Date().toLocaleTimeString();
            
            status.innerHTML = `<span class="${type}">[${timestamp}] ${message}</span>`;
            console.log(`[${type.toUpperCase()}] ${message}`);
        }
        
        // Register cursor listener component
        AFRAME.registerComponent('cursor-listener', {
            init: function () {
                this.el.addEventListener('mouseenter', function () {
                    this.setAttribute('scale', '1.1 1.1 1.1');
                });
                this.el.addEventListener('mouseleave', function () {
                    this.setAttribute('scale', '1 1 1');
                });
            }
        });
    </script>
</body>
</html>
