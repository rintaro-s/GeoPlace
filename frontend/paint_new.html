<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GeoPlace - Paint Tool</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #fff;
            height: 100vh;
            display: flex;
            overflow: hidden;
        }
        
        #sidebar {
            width: 300px;
            background: #2d2d2d;
            padding: 20px;
            border-right: 2px solid #444;
            overflow-y: auto;
            flex-shrink: 0;
        }
        
        #main {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #333;
        }
        
        #toolbar {
            background: #2d2d2d;
            padding: 15px;
            border-bottom: 1px solid #444;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        #canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: #222;
        }
        
        #canvas {
            position: absolute;
            cursor: crosshair;
            image-rendering: pixelated;
        }
        
        .section {
            background: #3a3a3a;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }
        
        .section h3 {
            color: #4CAF50;
            margin-bottom: 10px;
            font-size: 16px;
            border-bottom: 1px solid #4CAF50;
            padding-bottom: 5px;
        }
        
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            width: 100%;
            margin: 5px 0;
        }
        
        button:hover { background: #45a049; }
        button:disabled { background: #666; cursor: not-allowed; }
        
        input, select {
            width: 100%;
            padding: 8px;
            border: 1px solid #555;
            background: #444;
            color: #fff;
            border-radius: 4px;
            margin: 5px 0;
        }
        
        input[type="color"] {
            height: 40px;
            padding: 2px;
        }
        
        label {
            display: block;
            margin: 10px 0 5px 0;
            font-size: 14px;
            color: #ccc;
        }
        
        #status {
            background: #1a1a1a;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid #444;
        }
        
        #coordinates {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
        }
        
        .success { color: #4CAF50; }
        .error { color: #f44336; }
        .warning { color: #ff9800; }
        .info { color: #2196F3; }
    </style>
</head>
<body>
    <div id="sidebar">
        <h2>üé® Paint Tool</h2>
        
        <div class="section">
            <h3>üñåÔ∏è Brush Settings</h3>
            <label>Color:</label>
            <input type="color" id="brush-color" value="#00ff00">
            
            <label>Size:</label>
            <input type="range" id="brush-size" min="1" max="20" value="3">
            <span id="brush-size-display">3</span>
            
            <label>Tool:</label>
            <select id="tool-select">
                <option value="brush">Brush</option>
                <option value="eraser">Eraser</option>
            </select>
        </div>
        
        <div class="section">
            <h3>üéØ Actions</h3>
            <button id="save-btn">üíæ Save Changes</button>
            <button id="generate-btn">üöÄ Generate 3D</button>
            <button id="clear-btn">üóëÔ∏è Clear Canvas</button>
        </div>
        
        <div class="section">
            <h3>üìä Status</h3>
            <div>Modified Tiles: <span id="modified-count">0</span></div>
            <div>Zoom: <span id="zoom-display">100%</span></div>
            <div id="status"></div>
        </div>
        
        <div class="section">
            <h3>üîó Navigation</h3>
            <button onclick="window.open('/world', '_blank')">üåç 3D World</button>
            <button onclick="window.open('/admin', '_blank')">‚öôÔ∏è Admin</button>
        </div>
    </div>
    
    <div id="main">
        <div id="toolbar">
            <button id="zoom-in">üîç+</button>
            <button id="zoom-out">üîç-</button>
            <button id="zoom-reset">üéØ Reset View</button>
            <span>|</span>
            <span id="connection-status">üî¥ Disconnected</span>
        </div>
        
        <div id="canvas-container">
            <canvas id="canvas"></canvas>
            <div id="coordinates">X: 0, Y: 0</div>
        </div>
    </div>

    <script>
        // Global state
        let canvas, ctx;
        let isDrawing = false;
        let lastX = 0, lastY = 0;
        let zoom = 1;
        let offsetX = 0, offsetY = 0;
        let modifiedTiles = new Set();
        let tileCache = new Map();
        
        // Settings
        const TILE_SIZE = 32;
        const CANVAS_SIZE = 20000;
        
        // Initialize
        document.addEventListener('DOMContentLoaded', init);
        
        function init() {
            setupCanvas();
            setupEventListeners();
            testBackendConnection();
            loadInitialView();
            log('Paint tool initialized', 'success');
        }
        
        function setupCanvas() {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            
            // Set canvas size
            canvas.width = 800;
            canvas.height = 600;
            
            // Set up canvas properties
            ctx.imageSmoothingEnabled = false;
            ctx.fillStyle = '#222';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            log('Canvas initialized: 800x600', 'info');
        }
        
        function setupEventListeners() {
            // Canvas events
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);
            canvas.addEventListener('wheel', handleZoom);
            
            // UI events
            document.getElementById('brush-size').addEventListener('input', updateBrushSize);
            document.getElementById('save-btn').addEventListener('click', saveChanges);
            document.getElementById('generate-btn').addEventListener('click', generateModels);
            document.getElementById('clear-btn').addEventListener('click', clearCanvas);
            document.getElementById('zoom-in').addEventListener('click', () => setZoom(zoom * 1.2));
            document.getElementById('zoom-out').addEventListener('click', () => setZoom(zoom / 1.2));
            document.getElementById('zoom-reset').addEventListener('click', resetView);
            
            // Mouse tracking
            canvas.addEventListener('mousemove', updateCoordinates);
        }
        
        async function testBackendConnection() {
            try {
                const response = await fetch('/tile/0/0');
                if (response.ok) {
                    log('‚úÖ Backend connection successful', 'success');
                    document.getElementById('connection-status').innerHTML = 'üü¢ Connected';
                } else {
                    throw new Error(`HTTP ${response.status}`);
                }
            } catch (error) {
                log(`‚ùå Backend connection failed: ${error.message}`, 'error');
                document.getElementById('connection-status').innerHTML = 'üî¥ Connection Error';
            }
        }
        
        async function loadInitialView() {
            try {
                // Load a few tiles around center to test
                const centerTileX = Math.floor(CANVAS_SIZE / TILE_SIZE / 2);
                const centerTileY = Math.floor(CANVAS_SIZE / TILE_SIZE / 2);
                
                for (let dx = -2; dx <= 2; dx++) {
                    for (let dy = -2; dy <= 2; dy++) {
                        await loadTile(centerTileX + dx, centerTileY + dy);
                    }
                }
                
                log(`Loaded initial tiles around (${centerTileX}, ${centerTileY})`, 'info');
            } catch (error) {
                log(`Failed to load initial view: ${error.message}`, 'error');
            }
        }
        
        async function loadTile(tileX, tileY) {
            const key = `${tileX},${tileY}`;
            
            if (tileCache.has(key)) {
                return tileCache.get(key);
            }
            
            try {
                const response = await fetch(`/tile/${tileX}/${tileY}`);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const blob = await response.blob();
                const img = new Image();
                
                return new Promise((resolve, reject) => {
                    img.onload = () => {
                        tileCache.set(key, img);
                        drawTileToCanvas(img, tileX, tileY);
                        resolve(img);
                    };
                    img.onerror = reject;
                    img.src = URL.createObjectURL(blob);
                });
                
            } catch (error) {
                log(`Failed to load tile (${tileX}, ${tileY}): ${error.message}`, 'error');
                return null;
            }
        }
        
        function drawTileToCanvas(img, tileX, tileY) {
            const x = (tileX * TILE_SIZE - offsetX) * zoom;
            const y = (tileY * TILE_SIZE - offsetY) * zoom;
            const size = TILE_SIZE * zoom;
            
            ctx.drawImage(img, x, y, size, size);
        }
        
        function startDrawing(e) {
            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            lastX = e.clientX - rect.left;
            lastY = e.clientY - rect.top;
        }
        
        function draw(e) {
            if (!isDrawing) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const brushSize = parseInt(document.getElementById('brush-size').value);
            const brushColor = document.getElementById('brush-color').value;
            const tool = document.getElementById('tool-select').value;
            
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(x, y);
            ctx.strokeStyle = tool === 'eraser' ? '#222' : brushColor;
            ctx.lineWidth = brushSize;
            ctx.lineCap = 'round';
            ctx.stroke();
            
            // Track modified tiles
            const worldX = (x / zoom) + offsetX;
            const worldY = (y / zoom) + offsetY;
            const tileX = Math.floor(worldX / TILE_SIZE);
            const tileY = Math.floor(worldY / TILE_SIZE);
            modifiedTiles.add(`${tileX},${tileY}`);
            
            updateModifiedCount();
            
            lastX = x;
            lastY = y;
        }
        
        function stopDrawing() {
            isDrawing = false;
        }
        
        function handleZoom(e) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            setZoom(zoom * delta);
        }
        
        function setZoom(newZoom) {
            zoom = Math.max(0.1, Math.min(5, newZoom));
            document.getElementById('zoom-display').textContent = Math.round(zoom * 100) + '%';
            redrawCanvas();
        }
        
        function resetView() {
            zoom = 1;
            offsetX = 0;
            offsetY = 0;
            document.getElementById('zoom-display').textContent = '100%';
            redrawCanvas();
        }
        
        function redrawCanvas() {
            ctx.fillStyle = '#222';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Redraw visible tiles
            const startTileX = Math.floor(offsetX / TILE_SIZE) - 1;
            const startTileY = Math.floor(offsetY / TILE_SIZE) - 1;
            const endTileX = startTileX + Math.ceil(canvas.width / (TILE_SIZE * zoom)) + 2;
            const endTileY = startTileY + Math.ceil(canvas.height / (TILE_SIZE * zoom)) + 2;
            
            for (let tileX = startTileX; tileX <= endTileX; tileX++) {
                for (let tileY = startTileY; tileY <= endTileY; tileY++) {
                    const key = `${tileX},${tileY}`;
                    if (tileCache.has(key)) {
                        drawTileToCanvas(tileCache.get(key), tileX, tileY);
                    }
                }
            }
        }
        
        async function saveChanges() {
            if (modifiedTiles.size === 0) {
                log('No changes to save', 'warning');
                return;
            }
            
            try {
                document.getElementById('save-btn').disabled = true;
                log(`Saving ${modifiedTiles.size} modified tiles...`, 'info');
                
                // For now, just simulate save
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                log('‚úÖ Changes saved successfully', 'success');
                modifiedTiles.clear();
                updateModifiedCount();
                
            } catch (error) {
                log(`‚ùå Save failed: ${error.message}`, 'error');
            } finally {
                document.getElementById('save-btn').disabled = false;
            }
        }
        
        async function generateModels() {
            if (modifiedTiles.size === 0) {
                log('No modified tiles to generate', 'warning');
                return;
            }
            
            try {
                document.getElementById('generate-btn').disabled = true;
                log(`Starting 3D generation for ${modifiedTiles.size} tiles...`, 'info');
                
                const response = await fetch('/generate_api', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ tiles: Array.from(modifiedTiles) })
                });
                
                const result = await response.json();
                
                if (result.ok !== false) {
                    log(`‚úÖ Generation started: ${result.message}`, 'success');
                } else {
                    throw new Error(result.error || 'Generation failed');
                }
                
            } catch (error) {
                log(`‚ùå Generation failed: ${error.message}`, 'error');
            } finally {
                document.getElementById('generate-btn').disabled = false;
            }
        }
        
        function clearCanvas() {
            if (confirm('Clear all changes? This cannot be undone.')) {
                ctx.fillStyle = '#222';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                modifiedTiles.clear();
                updateModifiedCount();
                log('Canvas cleared', 'info');
            }
        }
        
        function updateBrushSize() {
            const size = document.getElementById('brush-size').value;
            document.getElementById('brush-size-display').textContent = size;
        }
        
        function updateCoordinates(e) {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor(((e.clientX - rect.left) / zoom) + offsetX);
            const y = Math.floor(((e.clientY - rect.top) / zoom) + offsetY);
            document.getElementById('coordinates').textContent = `X: ${x}, Y: ${y}`;
        }
        
        function updateModifiedCount() {
            document.getElementById('modified-count').textContent = modifiedTiles.size;
        }
        
        function log(message, type = 'info') {
            const status = document.getElementById('status');
            const timestamp = new Date().toLocaleTimeString();
            const className = type;
            
            const div = document.createElement('div');
            div.className = className;
            div.textContent = `[${timestamp}] ${message}`;
            
            status.insertBefore(div, status.firstChild);
            
            // Keep only last 20 messages
            while (status.children.length > 20) {
                status.removeChild(status.lastChild);
            }
            
            console.log(`[${type.toUpperCase()}] ${message}`);
        }
    </script>
</body>
</html>
