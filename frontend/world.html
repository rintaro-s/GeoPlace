<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>GeoPlace World</title>
  <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
  <style>
    body { margin:0; }
    #hud { position:absolute; top:8px; left:8px; background:rgba(0,0,0,0.55); color:#fff; padding:6px; font-size:12px; max-width:300px; }
  </style>
</head>
<body>
  <div id="hud">Connecting...</div>
  <a-scene>
    <a-entity position="0 1.6 5">
      <a-entity camera look-controls wasd-controls></a-entity>
    </a-entity>
    <a-entity id="objects-root"></a-entity>
    <a-plane position="0 0 0" rotation="-90 0 0" width="1000" height="1000" color="#222"></a-plane>
    <a-sky color="#111"></a-sky>
  </a-scene>
  <script>
    const root = document.getElementById('objects-root');
    const hud = document.getElementById('hud');
    const WS_URL = (location.origin.replace(/^http/,'ws')) + '/ws';
    let objects = [];

    function renderObjects(objs){
      objects = objs;
      root.innerHTML='';
      objs.forEach(o=>{
        const e = document.createElement('a-entity');
        e.setAttribute('gltf-model', o.glb_url);
        e.setAttribute('position', `${o.x} ${o.y} ${o.z}`);
        e.setAttribute('rotation', o.rotation.join(' '));
  // scale will be set later after position/rotation are adjusted
        // quality color ring
        if (o.quality === 'refined') e.setAttribute('material','color:#FFF;opacity:0.95');
        
        // Set model or fallback to primitive - support both GLB and OBJ
        if (o.glb_url && o.glb_url !== '/assets/glb/GLB_PLACEHOLDER') {
          if (o.glb_url.endsWith('.obj')) {
            // Load OBJ; prefer MTL if present. If MTL isn't present but a PNG exists,
            // apply the PNG as a texture client-side after the model loads.
            const objUrl = o.glb_url;
            e.setAttribute('obj-model', `obj: ${objUrl}`);

            // candidate PNG urls to try (primary and fallback)
            const pngCandidates = [objUrl.replace('.obj', '.png'), objUrl.replace('.obj', '_fallback.png')];

            // helper: check if url exists by attempting to load an Image
            function checkImage(url) {
              return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => resolve(true);
                img.onerror = () => resolve(false);
                img.src = url;
              });
            }

            // After model loaded, verify materials; if no texture maps found, try to apply a PNG
            e.addEventListener('model-loaded', async () => {
              try {
                const threeObj = e.getObject3D('mesh') || e.getObject3D('model');
                if (!threeObj) return;

                // detect whether any material already has a map
                let hasMap = false;
                threeObj.traverse((node) => {
                  if (node.isMesh && node.material) {
                    const mats = Array.isArray(node.material) ? node.material : [node.material];
                    for (const m of mats) {
                      if (m && m.map) { hasMap = true; break; }
                    }
                  }
                });

                if (hasMap) return; // already textured

                // try candidates
                let foundPng = null;
                for (const u of pngCandidates) {
                  // convert asset path like /assets/glb/xxx.obj -> same-origin relative path
                  const url = u.startsWith('/') ? u : u;
                  // check availability
                  // Note: this will succeed if the dev server serves the png
                  // as static file.
                  // eslint-disable-next-line no-await-in-loop
                  if (await checkImage(url)) { foundPng = url; break; }
                }

                if (!foundPng) return;

                // load texture and apply to all mesh materials
                const loader = new THREE.TextureLoader();
                loader.load(foundPng, (tex) => {
                  tex.flipY = false; // OBJ UVs often expect this
                  threeObj.traverse((node) => {
                    if (node.isMesh) {
                      const mats = Array.isArray(node.material) ? node.material : [node.material];
                      for (const m of mats) {
                        try {
                          if (m) {
                            m.map = tex;
                            m.needsUpdate = true;
                          }
                        } catch (e) { /* ignore */ }
                      }
                    }
                  });
                });
              } catch (e) {
                console.error('Failed to apply PNG texture to OBJ', e);
              }
            });
          } else {
            e.setAttribute('gltf-model', o.glb_url);
          }
        } else {
          // Fallback to colored box for placeholder objects
          e.setAttribute('geometry', 'primitive: box; width: 1; height: 1; depth: 1');
          const colors = ['#4CAF50', '#2196F3', '#FF9800', '#E91E63', '#9C27B0'];
          e.setAttribute('material', `color: ${colors[index % colors.length]}; roughness: 0.3; metalness: 0.1`);
        }
        
  e.setAttribute('position', `${o.x} ${o.y + 0.5} ${o.z}`);
  e.setAttribute('rotation', (o.rotation || [0,0,0]).join(' '));
  const sc = o.scale || 1.0;
  e.setAttribute('scale', `${sc} ${sc} ${sc}`);
        e.setAttribute('shadow', 'cast: true; receive: true');
        
        // Quality indicator
        if (o.quality === 'refined') {
          e.setAttribute('animation', 'property: rotation; to: 0 360 0; loop: true; dur: 10000');
        }
        
        // Click interaction
        e.setAttribute('class', 'clickable');
        e.addEventListener('click', ()=>{
          hud.textContent = `id: ${o.id}\nquality: ${o.quality}\nurl: ${o.glb_url}`;
        });
        root.appendChild(e);
      });
      hud.textContent = `Objects: ${objs.length}`;
    }

    function connectWS(){
      const ws = new WebSocket(WS_URL);
      ws.onmessage = ev => { try{ const msg=JSON.parse(ev.data); handleWS(msg);}catch(e){console.error(e);} };
      ws.onopen = ()=> hud.textContent='Connected (waiting updates)';
      ws.onclose = ()=> { hud.textContent='Reconnecting...'; setTimeout(connectWS,1500); };
    }
    function handleWS(msg){
      if (msg.type==='hello'){ renderObjects(msg.objects); }
      if (msg.type==='job_progress' || msg.type==='job_done'){
        // 再取得
        fetch('/api/objects.json').then(r=>r.json()).then(renderObjects);
      }
    }

    connectWS();
  </script>
</body>
</html>
